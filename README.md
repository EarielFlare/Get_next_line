# Get_next_line
Get next line project without bonuses for School42. Passes Tripouille gnlTester.

Проект состоит из трех файлов: хэдер (прототипы, все дела), и собственно двух .c файлов.
get_next_line_utils.c содержит 5 функций из написанной ранее библиотеки libft.a.
Единственное отличие - в функции ft_strjoin в конце есть команда free (s1), которая
не влезала по норминету в основную функцию - банальная экономия 1 строки, извините,
более элегантного решения не придумал. Все остальные функции без изменений.
get_next_line.c содержит 3 основных функции (которых могло быть 2, или даже 1, - норминет).
Не самое красивое решение задачи, как по мне, однако оно мне понятно с точки зрения алгоритма.
По сути, функция get_next_line делает всякие приготовления для переменной remain (задача
которой - хранить данные между вызовами функции get_next_line), до и после вызова
функции ft_line_cycle. Функция ft_line_cycle крутит шарманку, пока не получит вменяемое значение
переменной line, которую можно вернуть в программу. Задача шарманки - считать кусок строки
из файла (если есть необходимость), добавить его в хвост переменной tmpl1, и вкинуть этот хлам
в функцию ft_line_ret на предмет поиска там символа переноса строки \n. Также шарманка содержит
условие выхода по последней строке файла, не содержащей в себе символа \n (но содержащей \0).

Важным плюсом, как по мне, является тот факт, что малочные переменные имеют понятную точку
создания и точку освобождения. Не нужно искать, куда уплыла та или иная память. Хотя есть
предположение, что переменную remain можно было использовать вместо tmpl1, а то чо она,
только для хранения данных используется. В общем, если б не норминет, было бы 2 функции
плюс 5 стандартных, а так, ну.. вот как-то так.
